import Cat.Fam.CatLemmas
import Cat.Fam.Categories.Setoid

/-! # Functors -/

namespace Cat



section laws

  variable
    {‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ : Fam.Cat}
    (fObj : ‚ÑÇ‚ÇÅ.Obj ‚Üí ‚ÑÇ‚ÇÇ.Obj)
    (fMap :
      {Œ± Œ≤ : ‚ÑÇ‚ÇÅ.Obj}
      ‚Üí ‚ÑÇ‚ÇÅ.Hom Œ± Œ≤ ‚áí ‚ÑÇ‚ÇÇ.Hom (fObj Œ±) (fObj Œ≤)
    )

  /-- Functor composition law. -/
  @[simp]
  abbrev Fam.Cat.Func.law.comp
    {Œ± Œ≤ Œ≥ : ‚ÑÇ‚ÇÅ.Obj}
    (f : Œ≤ ‚Ü† Œ≥)
    (g : Œ± ‚Ü† Œ≤)
  : Prop :=
    fMap (f ‚äö g) ‚âà (fMap f) ‚äö (fMap g)

  /-- Functor identity law. -/
  @[simp]
  protected abbrev Fam.Cat.Func.law.id
    {Œ± : ‚ÑÇ‚ÇÅ.Obj}
  : Prop :=
    @fMap Œ± Œ± ‚ÑÇ‚ÇÅ.id ‚âà ‚ÑÇ‚ÇÇ.id

  /-- Functor identity law (explicit version). -/
  @[simp]
  protected abbrev Fam.Cat.Func.law.id'
    (Œ± : ‚ÑÇ‚ÇÅ.Obj)
  : Prop :=
    @law.id ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ fObj fMap Œ±

end laws



/-- A functor transforms objects/arrows and respects composition/identity laws.  -/
structure Fam.Cat.Func (‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ : Cat) where
  /-- Maps `‚ÑÇ`-objects to `‚ÑÇ‚ÇÇ`-objects. -/
  fObj : ‚ÑÇ‚ÇÅ.Obj ‚Üí ‚ÑÇ‚ÇÇ.Obj
  /-- Maps `‚ÑÇ‚ÇÅ`-arrows to `‚ÑÇ‚ÇÇ`-arrows. -/
  fMap :
    {Œ± Œ≤ : ‚ÑÇ‚ÇÅ.Obj}
    ‚Üí ‚ÑÇ‚ÇÅ.Hom Œ± Œ≤ ‚áí ‚ÑÇ‚ÇÇ.Hom (fObj Œ±) (fObj Œ≤)
  /-- Functor composition law. -/
  comp_law
    {Œ± Œ≤ Œ≥ : ‚ÑÇ‚ÇÅ.Obj}
    (f : Œ≤ ‚Ü† Œ≥)
    (g : Œ± ‚Ü† Œ≤)
  : Func.law.comp fObj fMap f g
  /-- Functor identity law. -/
  id_law
    {Œ± : ‚ÑÇ‚ÇÅ.Obj}
  : Func.law.id' fObj fMap Œ±

/-- Maps `‚ÑÇ‚ÇÅ`-arrows to `‚ÑÇ‚ÇÇ`-arrows (explicit version). -/
@[simp]
abbrev Fam.Cat.Func.fMap'
  {F : Func ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ}
  (Œ± Œ≤ : ‚ÑÇ‚ÇÅ.Obj)
:=
  F.fMap (Œ± := Œ±) (Œ≤ := Œ≤)

/-- Functor composition law (explicit version). -/
@[simp]
abbrev Fam.Cat.Func.comp_law'
  {F : Func ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ}
  (Œ± Œ≤ Œ≥ : ‚ÑÇ‚ÇÅ.Obj)
:=
  @Func.comp_law ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ F Œ± Œ≤ Œ≥

/-- Functor identity law (explicit version). -/
@[simp]
abbrev Fam.Cat.Func.id_law'
  {F : Func ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ}
  (Œ± : ‚ÑÇ‚ÇÅ.Obj)
:=
  @Func.id_law ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ F Œ±

/-- Applied version of `F.fMap`. -/
def Fam.Cat.Func.fmap
  {F : Func ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ}
  {Œ± Œ≤ : ‚ÑÇ‚ÇÅ.Obj}
: (Œ± ‚Ü† Œ≤) ‚Üí (F.fObj Œ± ‚Ü† F.fObj Œ≤) :=
  fun f =>
    F.fMap f



-- /-- Allows writing `F object` for `F.fObj object` -/
-- instance instCoeFunFunctorObj
--   {‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ : Fam.Cat}
-- : CoeFun
--   (Fam.Cat.Func ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ)
--   (ùïÇ $ ‚ÑÇ‚ÇÅ.Obj ‚Üí ‚ÑÇ‚ÇÇ.Obj)
-- where
--   coe F :=
--     F.fObj

-- example
--   (F : Fam.Cat.Func ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ)
--   (Œ± : ‚ÑÇ‚ÇÅ.Obj)
-- : ‚ÑÇ‚ÇÇ.Obj :=
--   F Œ±



-- /-- Allows writing `F hom` for `F.fmap hom`. -/
-- instance instCoeFunFunctorHom
--   {‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ : Fam.Cat}
--   {Œ± Œ≤ : ‚ÑÇ‚ÇÅ.Obj}
-- : CoeFun
--   (Fam.Cat.Func ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ)
--   (fun F =>
--     (Œ± ‚Ü† Œ≤) ‚Üí (F.fObj Œ± ‚Ü† F.fObj Œ≤)
--   )
-- where
--   coe F :=
--     F.fmap

-- example
--   (F : Fam.Cat.Func ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ)
--   (f : Œ± ‚Ü† Œ≤)
-- : F.fObj Œ± ‚Ü† F.fObj Œ≤ :=
--   F f



/-- `fMap` is proper for `‚âà`. -/
theorem Fam.Cat.Func.fmap_proper
  (F : Func ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ)
  {Œ± Œ≤ : ‚ÑÇ‚ÇÅ.Obj}
  (f‚ÇÅ f‚ÇÇ : Œ± ‚Ü† Œ≤)
: f‚ÇÅ ‚âà f‚ÇÇ ‚Üí F.fmap f‚ÇÅ ‚âà F.fmap f‚ÇÇ :=
  F.fMap.proper



/-! ## Setoid of functors -/
section setoid
  variable
    {‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ : Fam.Cat}
    (F G : Fam.Cat.Func ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ)

  /-- Functor equivalence is `fmap` equivalence. -/
  @[simp]
  abbrev Fam.Cat.Func.equiv
  : Prop :=
    ‚àÄ {Œ± Œ≤ : ‚ÑÇ‚ÇÅ.Obj} (f : Œ± ‚Ü† Œ≤), F.fmap f ‚âã G.fmap f

  instance instFuncHasEquiv
  : HasEquiv (Fam.Cat.Func ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ) where
    Equiv F G :=
      @Fam.Cat.Func.equiv ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ F G

  /-- Functor equivalence is reflexive. -/
  theorem Fam.Cat.Func.Equiv.refl
  : F ‚âà F :=
    fun f =>
      F.fmap f
      |> Hom.Equiv.refl

  /-- Functor equivalence is symmetric. -/
  theorem Fam.Cat.Func.Equiv.symm
    {F G : Func ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ}
  : F ‚âà G ‚Üí G ‚âà F :=
    fun h_FG _Œ± _Œ≤ f =>
      h_FG f
      |> Hom.Equiv.symm (F.fmap f) (G.fmap f)

  /-- Functor equivalence is transitive. -/
  theorem Fam.Cat.Func.Equiv.trans
    {F G H : Func ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ}
  : F ‚âà G ‚Üí G ‚âà H ‚Üí F ‚âà H :=
    fun h_FG h_GH _Œ± _Œ≤ f =>
      Hom.Equiv.trans
        (h_FG f)
        (h_GH f)

  /-- Functor equivalence is an equivalence relation. -/
  def Fam.Cat.Func.Equiv.proof
  : Equivalence (@Fam.Cat.Func.equiv ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ) :=
    ‚ü®refl, symm, trans‚ü©



  /-- Functors are setoids in the Lean sense. -/
  instance instZetoidFunc
  : Zetoid (Fam.Cat.Func ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ) where
    r :=
      Fam.Cat.Func.equiv
    iseqv :=
      Fam.Cat.Func.Equiv.proof

  /-- Functors are setoids in this library's sense. -/
  def Fam.Cat.Func.mkSetoid
    (‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ : Cat)
  : Setoid where
    Carrier :=
      Func ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ
    instZetoid :=
      instZetoidFunc

end setoid



/-! ## Family of Hom-functors

Functor `Hom(Œ±,-) : ‚ÑÇ ‚Üí Set`. Basically, this functor
- maps `Œ≤ : ‚ÑÇ.Obj` to `‚ÑÇ.Hom Œ± Œ≤`;
- maps `f : ‚ÑÇ.Hom Œ≤ Œ≥` to `fun (g : ‚ÑÇ.Hom Œ± Œ≤) => f ‚àò g`.

So `Œ±` is a kind of pivot we see `‚ÑÇ` through: a `Œ≤` only matters as far as we can go from `Œ±` to
`Œ≤`, and a `‚ÑÇ.Hom Œ≤ Œ≥` only matters as far as we can compose it with a `‚ÑÇ.Hom Œ± Œ≤`.
-/
section hom_functors
  variable
    {‚ÑÇ : Fam.Cat}
    {Œ± : ‚ÑÇ.Obj}

  @[simp]
  abbrev Fam.Cat.Func.FunSET.HomFunc.obj
    (Œ± Œ≤ : ‚ÑÇ.Obj)
  :=
    ‚ÑÇ.Hom Œ± Œ≤

  @[simp]
  abbrev Fam.Cat.Func.FunSET.HomFunc.hom
    (Œ± : ‚ÑÇ.Obj)
    {Œ≤ Œ≥ : ‚ÑÇ.Obj}
    (f : Œ≤ ‚Ü† Œ≥)
    (g : Œ± ‚Ü† Œ≤)
  : Œ± ‚Ü† Œ≥ :=
    f ‚äö g

  /-- `HomFunc.hom` is a morphism. -/
  @[simp]
  def Fam.Cat.Func.FunSET.HomFunc.morph
    (Œ± : ‚ÑÇ.Obj)
    (f : Œ≤ ‚Ü† Œ≥)
  : (‚ÑÇ.Hom Œ± Œ≤) ‚áí (‚ÑÇ.Hom Œ± Œ≥) where
    map :=
      hom Œ± f
    proper :=
      ‚ÑÇ.congr.right f



  /-- `HomFunc.morph` is itself a morphism.
  
  `HomFunc.Morph` will be the arrow-mapping in the `FunSET` functor.
  -/
  @[simp]
  def Fam.Cat.Func.FunSET.HomFunc.Morph
    (Œ± : ‚ÑÇ.Obj)
    {Œ≤ Œ≥ : ‚ÑÇ.Obj}
  : (‚ÑÇ.Hom Œ≤ Œ≥) ‚áí (Fam.Cat.SET.Hom (HomFunc.obj Œ± Œ≤) (HomFunc.obj Œ± Œ≥)) where
    map f :=
      HomFunc.morph Œ± f
    proper :=
      by
        intro f‚ÇÅ f‚ÇÇ h_f
        simp
        intro g
        apply ‚ÑÇ.congr.left g h_f

  /-- `HomFunc.Morph` respects the composition law. -/
  theorem Fam.Cat.Func.FunSET.HomFunc.Morph.comp_law
    (Œ± : ‚ÑÇ.Obj)
    {Œ≤ Œ≥ Œ¥ : ‚ÑÇ.Obj}
    (g : Œ≥ ‚Ü† Œ¥)
    (h : Œ≤ ‚Ü† Œ≥)
  : law.comp (‚ÑÇ‚ÇÅ := ‚ÑÇ) (‚ÑÇ‚ÇÇ := SET) (obj Œ±) (Morph Œ±) g h :=
    by
      intro param
      simp [
        kompose, compose',
        SET, Comp.toCat, Morph.app2,
        Morph.compose.Comp, Morph.compose
      ]

  /-- `HomFunc.Morph` respects the identity law. -/
  theorem Fam.Cat.Func.FunSET.HomFunc.Morph.id_law
    (Œ± Œ≤ : ‚ÑÇ.Obj)
  : law.id' (‚ÑÇ‚ÇÅ := ‚ÑÇ) (‚ÑÇ‚ÇÇ := SET) (obj Œ±) (Morph Œ±) Œ≤ :=
    by
      intro f
      simp [
        SET, Comp.toCat,
        Morph.id,
        kompose, compose',
        Morph.app2
      ]



  /-- Hom-functors are functors. -/
  def Fam.Cat.Func.FunSET
    {‚ÑÇ : Cat}
    (Œ± : ‚ÑÇ.Obj)
  : Func ‚ÑÇ SET where
    fObj :=
      Fam.Cat.Func.FunSET.HomFunc.obj Œ±
    fMap :=
      FunSET.HomFunc.Morph Œ±
    comp_law :=
      FunSET.HomFunc.Morph.comp_law Œ±
    id_law :=
      @FunSET.HomFunc.Morph.id_law _ Œ±

end hom_functors
