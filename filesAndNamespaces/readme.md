Lean 4 is a modern language so, in a project, the way sources are layed out on your filesystem
carries meaning. You cannot do anything non-trivial without understanding this first, and then you
need to understand how *namespaces* work. *"Namespace"* is exactly the same as *"module"* since lean
does not have functors.

This project also discusses the `import` mecanics.

> Whenever you see `filesAndNamespaces` or `FilesAndNamespaces` below, it stands for *"whatever the
> name of your project is"*. This allows for examples to work on the project in this folder.
>
> Any file/directory path mentioned below is given **from the root** of this project unless
> explicitely stated otherwise. The *"root of this project"* is where this `readme` file is.


# Projects and Files



A virgin lean project, which is created by `lake new ProjectName` or `lake init ProjectName`,
contains `lakefile.lean`, `lean-toolchain` and two lean files: `Main.lean` and `ProjectName.lean`.
We will only discuss lean files here, not lake's project configuration files.



We can think of projects as defining either a binary (a program) or an API (a library). `Main.lean`
is, quite obviously, the binary entry point.

```lean
import FilesAndNamespaces

def main : IO Unit :=
  IO.println s!"{hello} {world}!"
```

```
❯ lake build

❯ ./build/bin/filesAndNamespaces
life sucks!
```

What a hilarious, if cynical, subversion of expectations.



# Imports

Like many languages, lean 4's unit of compilation is *files*. So, the content of two different files
cannot both depend on each other: file-content-dependency must be a tree. Now, the beginning of a
`.lean` file always starts with a (potentially empty) sequence of `import <path>` *command*s.

> A *command* is a top level-item: type/function definition, namespace or section start/end... It
> always starts with a keyword optionally preceded by some modifiers (documentation,
> meta-attributes...). A *command* is **not** a *term* (an expression).

In `Main.lean`, the first line imports the path `FilesAndNamespaces`. This corresponds to
`FilesAndNamespaces.lean`, which is the API entry point of the project. It also starts with a bunch
of imports.

```lean
import FilesAndNamespaces.Init
import FilesAndNamespaces.Data
import FilesAndNamespaces.Combine
import FilesAndNamespaces.Words

def hello := Hello.sayIt
def world := World.sayIt
```

So, a path is a potentially empty sequence of identifier-then-dot-s, followed by a single
identifier. Having `import Dir1.Dir2.Dir3.File` in `SomePlace/MyFile.lean` tells lake (the project
manager) that it must compile `Dir1.Dir2.Dir3.File` before it compiles `SomePlace/MyFile.lean`; also
that compiling `MyFile` requires whatever compilation artefact was generated by compiling
`Dir1.Dir2.Dir3.File`.

Great pedagogy allowed you to intuit that this path corresponds to `Dir1/Dir2/Dir3/File.lean`
although you still need be to be taught *with respect to where*. The root. Of the project.
Regardless of where `SomePlace/MyFile.lean` is. Remember `FilesAndNamespaces.lean`'s `import`s:

```lean
import FilesAndNamespaces.Init
import FilesAndNamespaces.Data
import FilesAndNamespaces.Combine
import FilesAndNamespaces.Words
```

All paths correspond to actual files in the project:

```
❯ exa FilesAndNamespaces/*.lean
FilesAndNamespaces/Combine.lean  FilesAndNamespaces/Data.lean
FilesAndNamespaces/Init.lean     FilesAndNamespaces/Words.lean
```

Showing the project as a tree, its overall organization is layed out for us:

```
❯ exa -T
.
├── FilesAndNamespaces
│  ├── Combine
│  │  ├── Advanced.lean
│  │  └── Basics.lean
│  ├── Combine.lean
│  ├── Data
│  │  ├── Advanced.lean
│  │  └── Basics.lean
│  ├── Data.lean
│  ├── Init.lean
│  └── Words.lean
├── FilesAndNamespaces.lean
└── [...]
```

This layout communicates *intention*, but says nothing regarding file dependencies which is
specified by the various `import`s. The `Basics.lean`/`Advanced.lean` pattern that appears twice
above is common in lean 4's stdlib. By splitting a *"feature"* (`Combine`) in *stages* (`Basics` and
`Advanced`), different features can dependent on each other in various ways depending on the stage
considered.

For instance, `FilesAndNamespaces.Data.Basics` depends on (`import`s)
`FilesAndNamespaces.Combine.Basics`. On the other hand, `FilesAndNamespaces.Combine.Advanced`
depends on `FilesAndNamespaces.Data.Advanced`.



# Namespaces

Depending on your background, this next bit might be a bit confusing. In most languages, *modules*
(the *"equivalent"* of namespaces) aggregate top-level items such as function/type definitions and
(sub-) modules. A module is typically defined somewhere, and then whenever that module is in scope
one can access and use its (public) content.

```rust
mod my_module {
    pub fn blah() -> String {
        "something quirky about 42".into()
    }
}
// We're out of the module, `my_module` is now defined and can never change.
pub fn so_quirky() -> String {
    // We can use what's inside the module.
    my_module::blah()
}
// If we want to add something, like this function, to `my_module` we can't.
pub fn this_would_be_so_great_in_blah() -> String {
    "lazy".into()
}
```

The point is that the module is defined somewhere, and adding stuff must be done at its unique
definition site. Functors make things a bit more complex but never mind functors.

Lean 4's namespaces ain't like that. We *"get into"* one with `namespace MyNamespace`, and close
it with `end MyNamespace` or `<EOF>`. When a namespace is open, top-level items we write are added
to this namespace, like modules. The key difference is that we can get into any namespace at any
time.

Namespaces can be nested, so we have a tree of namespaces the root of which is the project's
top-level, nameless namespace called `_root_`. Similar to `import` (file) paths, namespace paths use
`.` to access nested namespaces.

Going back to modules briefly, in most languages a source file `blah.ext` will define a module
`blah` or `Blah`, and everything in `blah.ext` is inside this auto-generated module.

Lean 4's namespaces ain't like that. In **any** lean file of the project, no corresponding namespace
is auto-generated. Everything in a source file is in the library's top-level, nameless namespace
(the root of the namespace tree `_root_`).

Say we are defining a `List` type in `FilesAndNamespaces/Data/Basics.lean` by writing, after
`import`s but before anything else, the following.

```lean
import FilesAndNamespaces.Combine.Basics



-- currently adding to the library's top-level namespace `_root_`
namespace Lst
  -- currently adding to `_root_.Lst`
  inductive Lst (α : Type u) :=
    | nil : Lst α
    | cons : α → Lst α → Lst α

  -- make `nil` directly visible instead of `Lst.nil`
  export Lst (nil cons)
  -- define an infix notation for `Lst.cons`
  infixr:70 " :: " => Lst.cons
end Lst
```

Then, **in any source file compiled before or after this file (including this file)**, we can "get
into" the `Lst` namespace and augment it. For instance, `FilesAndNamespaces/Data/Advanced.lean`
can contain

```lean
import FilesAndNamespaces.Init
import FilesAndNamespaces.Data.Basics



-- currently inside the `_root_` namespace
namespace Lst
  -- currently inside `_root_.Lst`, and we `import`ed `FilesAndNamespaces.Data.Basics` so
  -- `Lst` is defined and visible. `Opt` comes from `Init.lean` in case you're wondering.
  def fold (init : β) (f : β → α → β) : Lst α → β
    | Lst.nil => init
    | head::tail => fold (f init head) f tail
namespace Lst

```

> Pro tip:
> ```lean
> def Blah.tru : Bool := true
> ```
> is syntactic sugar for
> ```lean
> namespace Blah
>   def tru : Bool := true
> end Blah
> ```

Typically, a lean 4 file starts with a bunch of imports, and then a `namespace Some.Thing`. So
everything after that is added to (`_root_.`)`Some.Thing`. There usually is no `end Some.Thing`,
ensuring we are in `Some.Thing` until `<EOF>`. However nothing prevents from "contributing" to more
than one super-namespace `Some.Thing` in a single file.



# Done

That's it. Feel free to look at the files in this project and tinker around.

Here's a brief description of the lean files in `FilesAndNamespaces` and their relations in case
it's helpful.

- `Init.lean`: found in many projects, contains basic stuff for everything else
    - adds the `Opt`ion type at top-level (`_root_`), not actually used in other files
- `Combine/Basics.lean`: augments namespace (`_root_.`)`Combine`
  - defines the `ToString` class requiring a `toString` conversion function
- `Data/Basics.lean`: imports `Combine.Basics`, augments namespace `Data`
  - defines the `Lst.Lst` type and a bunch of QoL stuff
  - instanciates `Combine.ToString` for `String`
- `Data/Advanced.lean`: imports `Data.Basics`, augments namespace `Data`
  - defines `Lst.fold` (`fold` function in namespace `Data.Lst`)
- `Combine/Advanced.lean`: imports `Data.Advanced`, augments namespace `Combine`
  - defines `join` which merges to `ToString`s
  - and `fold` which merges the elements of a list of `ToString`s
- `Words.lean`: imports `Data` and `Combine`, augments namespaces `Hello` and `World`
  - defines functions `hello` and `world` by defining `Data.Lst`-s of single-character-string-s and
    `Combine.fold`-ing over them
  - guarantees hilarity thanks to classic subversion of expectations
